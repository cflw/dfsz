#include "玩家子弹_贯穿.h"
#include "敌机基础.h"
#include "游戏.h"
#include "图形引擎.h"
namespace 东方山寨 {
namespace 玩家子弹 {
const float C贯穿::c长度上限 = c屏幕范围r * 2;
const float C贯穿::c消失速度 = 1.f / 60.f;
void C贯穿::S状态::fs相对坐标(const t向量2 &p) {
	v相对坐标 = p - v绑定坐标[v坐标序号];
}
t向量2 C贯穿::S状态::fg实坐标() const {
	return v绑定坐标[v坐标序号] + v相对坐标;
}
void C贯穿::f接口_初始化() {
	v状态组.f新建(1, [this](S状态 &p, int i) {
		//v子弹扩展.v编号 = i;
		//p.v绑定坐标 = v玩家子弹制造机->v发射坐标;
		//p.v坐标序号 = v玩家子弹制造机->f取计数(1);
		//p.v数量序号 = v玩家子弹制造机->f取计数(2);
		//p.fs相对坐标(v坐标);
		p.v长度 = 0;
		p.v消失 = 0;
		p.f对象_使用();
	});
}
void C贯穿::f接口_销毁() {
	auto &v扩展状态 = f扩展_状态();
	v扩展状态.f对象_销毁();
}
void C贯穿::f接口_计算() {
	auto &v扩展状态 = f扩展_状态();
	//消失
	v扩展状态.v消失 += c消失速度;
	if (v扩展状态.v消失 < 0) {
		v扩展状态.v消失 = 0;
	} else if (v扩展状态.v消失 >= 1) {
		f对象_销毁();
		return;
	}
	//运动
	v扩展状态.v长度 = 数学::f线性渐变<float>(v扩展状态.v长度, c长度上限, m速度.fg大小() * m游戏速度->fg速度());
	m坐标 = v扩展状态.fg实坐标();
}
void C贯穿::f接口_显示() {
	//auto &v扩展状态 = f扩展_状态();
	//auto v画图形 = C游戏::fv资源().f图形()->f画图形();
	//v画图形->fs线条宽度(4);
	//v画图形->fs线条颜色({0, 0, 1, 1 - v扩展状态.v消失});
	//v画图形->f绘制线条(v坐标, fg末端());
}
void C贯穿::f接口_敌机判定(C敌机与玩家子弹判定 &p判定) {
	p判定.f玩家子弹_提交判定(t矩形::fc线段(m坐标, fg末端(), 4));
}
void C贯穿::f接口_发射() {
	//v玩家子弹制造机->f发射模板_从发射属性([&]() {
	//	bool v找到 = false;
	//	for (auto &v玩家子弹 : v玩家子弹制造机->va子弹->f循环_使用()) {
	//		if (v玩家子弹.f对象_w使用() && v玩家子弹.v子弹扩展.v指针 == this) {
	//			auto &v扩展状态 = v状态组[v玩家子弹.v子弹扩展.v编号];
	//			if ((v扩展状态.v绑定坐标 == v玩家子弹制造机->v发射坐标) && (v扩展状态.v坐标序号 == v玩家子弹制造机->f取计数(1)) && (v扩展状态.v数量序号 == v玩家子弹制造机->f取计数(2))) {
	//				v扩展状态.fs相对坐标(v玩家子弹制造机->v坐标);
	//				v玩家子弹.v速度 = v玩家子弹制造机->v速度;
	//				v扩展状态.v消失 -= c消失速度 * 2;
	//				v找到 = true;
	//				break;
	//			}
	//		}
	//	}
	//	if (!v找到) {
	//		v玩家子弹制造机->f产生子弹();
	//	}
	//});
}
C贯穿::S状态 &C贯穿::f扩展_状态() {
	return v状态组[0/*v子弹扩展.v编号*/];
}
t向量2 C贯穿::fg末端() {
	auto &v扩展状态 = f扩展_状态();
	return m坐标 + t向量2::fc方向r(v扩展状态.v长度, m速度.fg方向r());
}


}
}
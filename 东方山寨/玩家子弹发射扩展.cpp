#include "玩家子弹发射扩展.h"
#include "玩家子弹扩展.h"
#include "计算.h"
namespace 东方山寨::玩家子弹发射 {
//==============================================================================
// 工具
//==============================================================================
class C工具 {
public:
	static float f计算相对方向0(std::shared_ptr<I玩家发射环境> a发射环境, float(*af计算)(float)) {
		const float v方向0 = a发射环境->fg相对方向r() - C玩家子弹发射器::c前方向;
		const float v方向1 = af计算(v方向0);
		return v方向1 + C玩家子弹发射器::c前方向;
	}
	static float f计算相对方向1(std::shared_ptr<I玩家发射环境> a发射环境, float(*af计算)(float)) {
		const float v方向0 = a发射环境->fg相对方向r() - C玩家子弹发射器::c前方向;
		const float v方向1 = af计算(v方向0);
		const float v方向2 = 数学::f插值<float>(v方向1, 0, a发射环境->fg低速渐变());
		return v方向2 + C玩家子弹发射器::c前方向;
	}

};
//==============================================================================
// 自机基础
//==============================================================================
void C自机基础::f接口_产生子弹() {
	m子弹制造机->m参数.m坐标 = m发射环境->fg发射坐标();
	m子弹制造机->m参数.m速度 = {0, c速度大小};
	for (auto &v循环 : m子弹制造机->f循环(2)) {
		v循环.f变换模板_发散(m发射环境, {0, 0}, {20, 20});
		m子弹制造机->f产生子弹<C玩家子弹>();
	}
}
//==============================================================================
// 灵梦诱导
//==============================================================================
C灵梦诱导::C灵梦诱导():
	C玩家子弹发射器() {
	f属性_s发射间隔(c发射间隔);
}
void C灵梦诱导::f接口_产生子弹() {
	m子弹制造机->m参数.m坐标 = m发射环境->fg发射坐标();
	const float v方向1 = C工具::f计算相对方向1(m发射环境, [](float a方向)->float {
		return a方向 / 4;
	});
	m子弹制造机->m参数.m速度 = t向量2::fc方向r(c速度大小, v方向1);
	m子弹制造机->f产生子弹<玩家子弹::C诱导>();
}
//==============================================================================
// 灵梦集中
//==============================================================================
void C灵梦集中::f接口_产生子弹() {
	constexpr std::pair<float, float> c角度间隔 = {8 * 数学::c度到弧度<float>, 0};
	constexpr std::pair<float, float> c坐标间隔 = {10, 10};
	m子弹制造机->m参数.m坐标 = m发射环境->fg发射坐标();
	const float v方向1 = C工具::f计算相对方向1(m发射环境, [](float a方向)->float {
		return a方向 / 12;
	});
	m子弹制造机->m参数.m速度 = t向量2::fc方向r(c速度大小, v方向1);
	for (auto &v循环 : m子弹制造机->f循环(2)) {
		v循环.f变换模板_发散(m发射环境, c角度间隔, c坐标间隔);
		m子弹制造机->f产生子弹<C玩家子弹>();
	}
}

//==============================================================================
// 魔理沙贯穿
//==============================================================================
void C魔理沙贯穿::f接口_计算() {
	f基础_计算时间();
	if (f基础_i可发射()) {
		if (fi有子弹()) {
			m子弹->f持续();
		} else {
			f接口_产生子弹();
		}
	}
	//维持子弹坐标速度
	if (fi有子弹()) {
		玩家子弹::C贯穿 *const v子弹 = m子弹.get();
		v子弹->m坐标 = m发射环境->fg发射坐标();
		const float v方向1 = C工具::f计算相对方向1(m发射环境, [](float a方向)->float {
			return a方向 / 8;
		});
		v子弹->m速度 = t向量2::fc方向r(1000, v方向1);
	} else {
		m子弹 = nullptr;
	}
}
void C魔理沙贯穿::f接口_产生子弹() {
	m子弹制造机->m参数.m坐标 = m发射环境->fg发射坐标();
	m子弹制造机->m参数.m速度 = {0, 1000};
	m子弹 = m子弹制造机->f产生子弹<玩家子弹::C贯穿>();
}
bool C魔理沙贯穿::fi有子弹() const {
	return m子弹 && m子弹->f对象_i使用();
}
//==============================================================================
// 魔理沙范围
//==============================================================================
C魔理沙范围::C魔理沙范围() {
	f属性_s发射间隔(c发射间隔);
}
void C魔理沙范围::f接口_产生子弹() {
	constexpr std::pair<float, float> c角度间隔 = {16 * 数学::c度到弧度<float>, 4 * 数学::c度到弧度<float>};
	constexpr std::pair<float, float> c坐标间隔 = {0, 0};
	m子弹制造机->m参数.m坐标 = m发射环境->fg发射坐标();
	const float v方向0 = C工具::f计算相对方向0(m发射环境, [](float a方向)->float {
		return a方向 / 8;
	});
	m子弹制造机->m参数.m速度 = t向量2::fc方向r(c速度大小, v方向0);
	for (auto &v循环 : m子弹制造机->f循环(4)) {
		v循环.f变换模板_发散(m发射环境, c角度间隔, c坐标间隔);
		m子弹制造机->f产生子弹<C玩家子弹>();
	}
}


}
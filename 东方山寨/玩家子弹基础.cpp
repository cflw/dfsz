#include "标识.h"
#include "游戏.h"
#include "敌机基础.h"
#include "玩家.h"
#include "玩家子弹基础.h"
#include "计算.h"
#include "玩家子弹图形.h"
#include "玩家子弹图形模板.h"
#include "边框形状.h"
namespace 东方山寨 {
//==============================================================================
// 玩家子弹
//==============================================================================
void C玩家子弹::f对象_使用() {
	m标志[e使用] = true;
	m计数指针->f加计数();
}
void C玩家子弹::f对象_销毁() {
	assert(m标志[e使用]);	//禁止重复销毁
	this->f接口_销毁();
	m标志.reset();
	m计数指针->f减计数();
	m图形->fg图形缓冲().f对象_销毁();
}
bool C玩家子弹::f对象_i使用() const {
	return m标志[e使用];
}
const S玩家子弹属性 &C玩家子弹::f基础_g子弹属性() const {
	return *m子弹属性;
}
void C玩家子弹::f基础_计算运动() {
	计算::f基本运动计算(m坐标, m速度, m游戏速度->fg秒());
}
float C玩家子弹::f基础_计算方向() {
	if (!m速度.fi零()) {
		m方向 = m速度.fg方向r();
	}
	return m方向;
}
void C玩家子弹::f基础_计算时间() {
	m出现 += m游戏速度->fg秒();
}
C复杂形状 C玩家子弹::f基础_g判定形状() const {
	auto &v子弹属性 = f基础_g子弹属性();
	return C复杂形状::fc自动(m坐标, v子弹属性.m判定, m缩放, m方向);
}
bool C玩家子弹::f基础_i炸弹() const {
	return m标志[e炸弹];
}
int C玩家子弹::f属性_g伤害() const {
	return f基础_g子弹属性().m伤害;
}
float C玩家子弹::f基础_g出现透明度() const {
	return (m出现 < c出现透明度达到最大时间) ? ((m出现 / c出现透明度达到最大时间) * c透明度) : c透明度;
}
void C玩家子弹::f接口_初始化(const S玩家子弹参数 &a参数) {
	m坐标 = a参数.m坐标;
	m速度 = a参数.m速度;
	m方向 = a参数.m速度.fg方向r();
	if (a参数.m子弹属性) {
		m子弹属性 = a参数.m子弹属性;
	} else {
		auto &va子弹属性 = C游戏::fg资源().fg玩家子弹属性();
		m子弹属性 = va子弹属性.fg指针((int)E玩家子弹::e测试子弹);
	}
}
void C玩家子弹::f接口_初始化图形(C缓冲数组<I图形缓冲> &aa图形缓冲) {
	if (m子弹属性->m纹理) {
		m图形 = std::make_unique<C玩家子弹图形_图片>(*this, aa图形缓冲);
	} else {
		m图形 = std::make_unique<C玩家子弹图形_线条>(*this, aa图形缓冲);
	}
}
void C玩家子弹::f接口_计算() {
	f基础_计算运动();
	f基础_计算方向();
	f基础_计算时间();
	m图形->f计算();
}
void C玩家子弹::f接口_更新() {
	m图形->f更新();
}
void C玩家子弹::f接口_销毁() {
}
void C玩家子弹::f接口_消失() {
	f对象_销毁();
}
bool C玩家子弹::f接口_敌机判定(C敌机与玩家子弹判定 &a判定) {
	const bool v结果 = a判定.f玩家子弹_提交判定(t圆形{m坐标, this->f接口_g判定半径()});
	if (v结果) {
		this->f接口_命中敌机(*a判定.m敌机);
	}
	return v结果;
}
void C玩家子弹::f接口_命中敌机(const C敌机 &) {
	m标志[e命中可销毁] = true;
	if (m子弹属性->m纹理) {	//图片
		图形模板::f玩家子弹消失(*this);
	} else {	//线条
		
	}
}
bool C玩家子弹::f接口_在窗口外() {
	return 边框::C矩形::c窗口.f判断(m坐标, 0);
}
float C玩家子弹::f接口_g判定半径() const {
	return c判定半径;
}
//==============================================================================
// 玩家炸弹
//==============================================================================
namespace 玩家炸弹 {
}	//namespace 玩家炸弹
}	//namespace 东方山寨
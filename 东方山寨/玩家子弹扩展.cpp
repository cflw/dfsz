#include "玩家子弹扩展.h"
#include "敌机基础.h"
#include "游戏.h"
#include "玩家子弹图形模板.h"
#include "图形_画图片.h"
namespace 东方山寨::玩家子弹 {
//==============================================================================
// 诱导
//==============================================================================
C诱导::C诱导():
	ma敌机{&C游戏::g内容.fg敌机数组()} {
}
void C诱导::f接口_计算() {
	if (m生命 > 0) {
		std::shared_ptr<C敌机> v目标 = m目标.lock();
		//寻找目标
		if (v目标 && !v目标->f对象_i使用()) {	//原来有目标但是现在没了
			v目标 = f寻找目标();
		} else {	//没目标
			v目标 = f寻找目标();
		}
		//确定目标
		if (v目标) {
			const float v目标方向 = m坐标.f到点方向r(v目标->m坐标);
			const float v子弹方向 = m速度.fg方向r();
			m速度.fs方向(数学::C角度计算<float>::c弧度.f旋转渐变(v子弹方向, v目标方向, c角速度));
		}
		//其它
		m目标 = v目标;
		m生命 -= m游戏速度->fg秒();
	}
	f基础_计算运动();
	f基础_计算方向();
	f基础_计算时间();
}
std::shared_ptr<C敌机> C诱导::f寻找目标() {
	std::shared_ptr<C敌机> v目标敌机 = nullptr;
	float v目标分数 = 999999;
	ma敌机->fe使用p([&](std::shared_ptr<C敌机> a当前敌机) {
		const C敌机 &v当前敌机 = *a当前敌机;
		const float v方向0 = m坐标.f到点方向r(v当前敌机.m坐标);
		const float v方向1 = 数学::C角度计算<float>::c弧度.f夹角(v方向0, m速度.fg方向r());
		const float v距离 = m坐标.f到点距离(v当前敌机.m坐标);
		const float v分数 = v距离 * v方向1 * v方向1;
		if (v分数 < v目标分数) {
			v目标敌机 = a当前敌机;
			v目标分数 = v分数;
		}
	});
	return v目标敌机;
}
//==============================================================================
// 贯穿
//==============================================================================
void C贯穿::f接口_计算() {
	const float v过秒 = m游戏速度->fg秒();
	//消失
	m消失 += c消失速度 * v过秒;
	if (m消失 < 0) {
		m消失 = 0;
	} else if (m消失 >= 1) {
		f对象_销毁();
		return;
	}
	//运动
	m长度 = 数学::f线性渐变<float>(m长度, c长度上限, m速度.fg大小() * v过秒);
	//其它
	f基础_计算时间();
	f基础_计算方向();
}
void C贯穿::f接口_显示() const {
	const float v消失透明度 = (1 - m消失) * c透明度;
	const float v出现透明度 = f基础_g出现透明度();
	const float v透明度 = std::min<float>(v出现透明度, v消失透明度);
	if (const auto &vp纹理 = m子弹属性->m纹理.m指针) {
		//准备顶点矩形
		const S顶点矩形 &v属性矩形 = *m子弹属性->m顶点.m指针;
		S顶点矩形 v矩形 = v属性矩形;
		v矩形.m坐标[0] = 0;
		v矩形.m坐标[2] = m长度;
		v矩形.m纹理[2] = v属性矩形.m纹理[2] / v属性矩形.fg宽() * m长度;
		v矩形.m纹理[0] -= m出现;
		v矩形.m纹理[2] -= m出现;
		//准备画图片
		auto &v画图片 = C游戏::fg图形().fg画图片();
		v画图片.fs纹理(*vp纹理);
		v画图片.fs坐标(m坐标);
		v画图片.fs透明度(v透明度);
		v画图片.f变换_重置();
		v画图片.f变换_旋转(m方向);
		v画图片.f画图片(v矩形);
	} else {
		auto &v画图形 = C游戏::fg图形().fg画图形();
		v画图形.fs线条宽度(4);
		v画图形.fs颜色({0, 0, 1, v透明度});
		v画图形.f绘制线条(t线段(m坐标, fg末端()));
	}
}
void C贯穿::f接口_敌机判定(C敌机与玩家子弹判定 &a判定) {
	if (m消失 >= 0.5f) {	//消失的子弹不参与判定
		return;
	}
	const bool v结果 = a判定.f玩家子弹_提交判定(t旋转矩形::fc线段(m坐标, fg末端(), 4));
	if (v结果) {
		f接口_命中敌机(*a判定.m敌机);
	}
}
void C贯穿::f接口_命中敌机(const C敌机 &a敌机) {
	if (m消失时间点 <= m出现 - c消失间隔 || m消失时间点 >= m出现) {
		m消失时间点 = m出现;
		//计算消失位置
		const float v敌机判定半径 = a敌机.fg判定半径();
		const t向量2 v敌机方位 = m坐标.f到点方位r(a敌机.m坐标, m方向);
		const float v水平距离差 = [&]()->float {
			const float v垂直距离 = abs(v敌机方位.y);
			if (v垂直距离 == 0) {
				return v敌机判定半径;
			} else {
				if (v垂直距离 >= v敌机判定半径) {
					return 0;
				} else {
					return 数学::f反勾股<float>(v敌机判定半径, v垂直距离);
				}
			}
		}();
		const t向量2 v速度 = t向量2::fc方向r(200, m方向);
		图形模板::f玩家子弹消失(m坐标 + t向量2::fc方向r(v敌机方位.x - v水平距离差, m方向), v速度, *m子弹属性);
	}
}
t向量2 C贯穿::fg末端() const {
	return m坐标 + t向量2::fc方向r(m长度, m速度.fg方向r());
}
void C贯穿::f持续() {
	m消失 -= c消失速度 * m游戏速度->fg秒() * 2;
}
}	//namespace 东方山寨::玩家子弹
#include "图形资源工厂.h"
#include "图形引擎.h"
#include "图形_三维.h"
#include "游戏.h"
#include "标识.h"
namespace 东方山寨 {
namespace 视窗 = cflw::视窗;
//==============================================================================
// 纹理工厂
//==============================================================================
C纹理工厂::~C纹理工厂() {
}
void C纹理工厂::f初始化(三维::C三维 &a三维, C属性数组<S纹理> &aa纹理) {
	m纹理工厂 = &a三维.fg纹理工厂();
	ma纹理 = &aa纹理;
}
const S纹理 *C纹理工厂::f创建纹理(int a标识, const std::wstring_view &a文件) const {
	if (ma纹理->fi不存在(a标识)) {
		if (a文件.empty()) {	//路径是空的
			return nullptr;
		}
		auto &v图像工厂 = m纹理工厂->fg图像工厂();
		auto v纹理 = v图像工厂.f一键读取(a文件);
		return f创建纹理(a标识, *v纹理);
	} else {
		return &ma纹理->fg数据(a标识);
	}
}
const S纹理 *C纹理工厂::f创建纹理(int a标识, const 纹理::I纹理 &a纹理) const {
	if (ma纹理->fi不存在(a标识)) {
		try {
			三维::tp纹理2 v纹理2;
			HRESULT hr = m纹理工厂->f从纹理对象创建纹理2(v纹理2, a纹理);
			视窗::f失败则抛出(hr);
			S纹理 v临时纹理;
			hr = m纹理工厂->f从纹理资源创建纹理资源视图(v临时纹理.m纹理, v纹理2, m纹理工厂->fg最近纹理描述());
			视窗::f失败则抛出(hr);
			v临时纹理.m尺寸 = t向量2(a纹理.fg宽(), a纹理.fg高());
			ma纹理->f添加(a标识, v临时纹理);
			return &ma纹理->ma数据.back();
		} catch (HRESULT hr) {
			return nullptr;
		}
	} else {
		return &ma纹理->fg数据(a标识);
	}
}
//==============================================================================
// 顶点工厂
//==============================================================================
C顶点矩形工厂::C循环::C循环(S参数 &a参数, int a列, int a行):
	m参数(&a参数),
	m行(a行), m列(a列), i(0), j(0),
	m参数备份(a参数) {
}
void C顶点矩形工厂::C循环::f循环控制_自增() {
	++i;
	if (i >= m列) {
		i -= m列;
		++j;
	}
	*m参数 = m参数备份;
}
bool C顶点矩形工厂::C循环::f循环控制_i继续() {
	return j < m行;
}
int C顶点矩形工厂::C循环::fg计数() const {
	return i + j * m列;
}
void C顶点矩形工厂::C循环::f变换_平移(const t向量2 &a向量) {
	t向量2 &v映射点 = m参数->m裁剪坐标;
	v映射点.x += a向量.x * i;
	v映射点.y += a向量.y * j;
}
//参数
void C顶点矩形工厂::S参数::f重置() {
	m标志.reset();
	m裁剪尺寸 = t向量2::c零;
	m纹理尺寸 = t向量2::c零;
	m纹理尺寸 = t向量2::c零;
	m裁剪坐标 = t向量2::c零;
	m裁剪尺寸偏移 = -0.5f;
}
C顶点矩形工厂::C循环 C顶点矩形工厂::S参数::f循环(int a列, int a行) {
	return C循环(*this, a列, a行);
}
void C顶点矩形工厂::S参数::fs裁剪半尺寸(const t向量2 &a半尺寸) {
	m裁剪尺寸 = a半尺寸 * 2;
}
void C顶点矩形工厂::S参数::fs裁剪尺寸(const t向量2 &a尺寸) {
	m裁剪尺寸 = a尺寸;
}
void C顶点矩形工厂::S参数::fs纹理尺寸(const t向量2 &a尺寸) {
	m纹理尺寸 = a尺寸;
}
void C顶点矩形工厂::S参数::fs裁剪坐标(const t向量2 &a偏移) {
	m裁剪坐标 = a偏移;
}
void C顶点矩形工厂::S参数::fs裁剪尺寸偏移(float a偏移) {
	m裁剪尺寸偏移 = a偏移;
}
void C顶点矩形工厂::S参数::fs矩形坐标(const t向量2 &a偏移) {
	m矩形坐标 = a偏移;
	m标志[e矩形坐标偏移] = true;
}
void C顶点矩形工厂::S参数::fs矩形半尺寸(const t向量2 &a半尺寸) {
	m矩形尺寸 = a半尺寸 * 2;
	m标志[e自定义矩形尺寸] = true;
}
void C顶点矩形工厂::S参数::fs矩形尺寸(const t向量2 &a尺寸) {
	m矩形尺寸 = a尺寸;
	m标志[e自定义矩形尺寸] = true;
}
void C顶点矩形工厂::S参数::fs矩形尺寸缩放(const t向量2 &a) {
	m矩形尺寸缩放 = a;
	m标志[e矩形尺寸缩放] = true;
}
void C顶点矩形工厂::S参数::fs相对原点缩放(const t向量2 &a) {
	m相对原点缩放 = a;
	m标志[e相对原点缩放] = true;
}
void f计算_赋尺寸(float *a, const t向量2 &a尺寸) {
	a[0] = -a尺寸.x * 0.5f;
	a[1] = a尺寸.y * 0.5f;
	a[2] = a尺寸.x * 0.5f;
	a[3] = -a尺寸.y * 0.5f;
}
void f计算_加向量(float *a, const t向量2 &a向量) {
	a[0] += a向量.x;
	a[1] += a向量.y;
	a[2] += a向量.x;
	a[3] += a向量.y;
}
void f计算_乘向量(float *a, const t向量2 &a向量) {
	a[0] *= a向量.x;
	a[1] *= a向量.y;
	a[2] *= a向量.x;
	a[3] *= a向量.y;
}
void C顶点矩形工厂::S参数::f计算_顶点坐标_矩形(float *a) const {
	f计算_赋尺寸(a, m矩形尺寸);
}
void C顶点矩形工厂::S参数::f计算_顶点坐标_裁剪(float *a) const {
	f计算_赋尺寸(a, m裁剪尺寸);
}
void C顶点矩形工厂::S参数::f计算_纹理坐标(float *a) const {
	a[0] = (m裁剪坐标.x - m裁剪尺寸偏移) / m纹理尺寸.x;
	a[1] = (m裁剪坐标.y - m裁剪尺寸偏移) / m纹理尺寸.y;
	a[2] = (m裁剪坐标.x + m裁剪尺寸.x + m裁剪尺寸偏移) / m纹理尺寸.x;
	a[3] = (m裁剪坐标.y + m裁剪尺寸.y + m裁剪尺寸偏移) / m纹理尺寸.y;
}
void C顶点矩形工厂::S参数::f计算_矩形尺寸缩放(float *a) const {
	f计算_乘向量(a, m矩形尺寸缩放);
}
void C顶点矩形工厂::S参数::f计算_矩形坐标缩放(float *a) const {
	f计算_乘向量(a, m相对原点缩放);
}
void C顶点矩形工厂::S参数::f计算_矩形坐标偏移(float *a) const {
	f计算_加向量(a, m矩形坐标);
}
//顶点工厂
void C顶点矩形工厂::f初始化(C属性数组<S顶点矩形> &a) {
	ma顶点矩形 = &a;
}
S顶点矩形 C顶点矩形工厂::fc顶点矩形(const C顶点矩形工厂::S参数 &a参数) {
	S顶点矩形 v矩形;
	if (a参数.m标志[e自定义矩形尺寸]) {
		f计算_赋尺寸(v矩形.m坐标, a参数.m矩形尺寸);
	} else {
		f计算_赋尺寸(v矩形.m坐标, a参数.m裁剪尺寸);
	}
	a参数.f计算_纹理坐标(v矩形.m纹理);
	if (a参数.m标志[e矩形尺寸缩放]) {
		a参数.f计算_矩形尺寸缩放(v矩形.m坐标);
	}
	if (a参数.m标志[e矩形坐标偏移]) {
		a参数.f计算_矩形坐标偏移(v矩形.m坐标);
	}
	if (a参数.m标志[e相对原点缩放]) {
		a参数.f计算_矩形坐标缩放(v矩形.m坐标);
	}
	return v矩形;
}
void C顶点矩形工厂::f创建矩形(int a标识, const S参数 &a参数) const {
	assert(ma顶点矩形->fi不存在(a标识));
	S顶点矩形 v矩形 = fc顶点矩形(a参数);
	ma顶点矩形->f添加(a标识, v矩形);
}
void C顶点矩形工厂::f复制矩形(int a新, int a旧) const {
	ma顶点矩形->f引用(a新, a旧);
}
void C顶点矩形工厂::f创建矩形_完整纹理(int a标识, const t向量2 &a纹理尺寸, float a缩放) const {
	S参数 v参数;
	v参数.fs裁剪尺寸(a纹理尺寸 / a缩放);	//缩放≠1 时可能有问题,以后再确认再改
	v参数.fs纹理尺寸(a纹理尺寸);
	v参数.fs裁剪坐标(t向量2::c零);
	f创建矩形(a标识, v参数);
}
void C顶点矩形工厂::f创建矩形_完整切割(int a标识, const t向量2 &a纹理尺寸, const t向量2 &a裁剪尺寸) const {
	const int v列 = (int)(a纹理尺寸.x / a裁剪尺寸.x);
	const int v行 = (int)(a纹理尺寸.y / a裁剪尺寸.y);
	S参数 v参数;
	v参数.fs裁剪尺寸(a裁剪尺寸);
	v参数.fs纹理尺寸(a纹理尺寸);
	v参数.fs裁剪坐标(t向量2::c零);
	for (auto &v循环 : v参数.f循环(v列, v行)) {
		v循环.f变换_平移(a裁剪尺寸);
		f创建矩形(计算::f标识(a标识, 0, v循环.fg计数()), v参数);
	}
}
void C顶点矩形工厂::f创建矩形_完整切割(int a标识, const t向量2 &a纹理尺寸, int a列, int a行) const {
	const t向量2 v矩形尺寸 = {a纹理尺寸.x / (float)a列, a纹理尺寸.y / (float)a行};
	S参数 v参数;
	v参数.fs裁剪尺寸(v矩形尺寸);
	v参数.fs纹理尺寸(a纹理尺寸);
	v参数.fs裁剪坐标(t向量2::c零);
	for (auto &v循环 : v参数.f循环(a列, a行)) {
		v循环.f变换_平移(v矩形尺寸);
		f创建矩形(计算::f标识(a标识, 0, v循环.fg计数()), v参数);
	}
}
//==============================================================================
// 模型工厂
//==============================================================================
void C模型工厂::S参数::fs顶点(const S三维顶点 *a指针, size_t a数量) {
	m顶点 = a指针;
	m顶点数 = a数量;
}
void C模型工厂::S参数::fs索引(const uint16_t *a指针, size_t a数量) {
	m索引 = a指针;
	m索引数 = a数量;
}
void C模型工厂::f初始化(C属性数组<C模型> &a) {
	ma模型 = &a;
}
void C模型工厂::f创建模型(int a标识) {
	ma模型->f构造(a标识, m参数.m顶点, m参数.m顶点数, m参数.m索引, m参数.m索引数);
}
}	//namespace 东方山寨
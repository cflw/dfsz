#include "图形_画图片.h"
#include "图形引擎.h"
#include "图形引擎_资源工厂.h"
#include "程序.h"
namespace 东方山寨 {
//==============================================================================
// 画图片
//==============================================================================
C画图片::C画图片(C图形引擎 &a引擎, 三维::C三维 &a三维) : m渲染控制{a三维.fg渲染控制()}, m渲染状态{a三维.fg渲染状态()}, m缓存{a三维} {
	三维::C顶点格式 v顶点格式;
	v顶点格式.f添加(三维::C顶点格式::e位置, 2);
	v顶点格式.f添加(三维::C顶点格式::e纹理, 2);
	v顶点格式.f添加("ALPHA", 1);
	auto &v着色器工厂 = a引擎.fg着色器工厂();
	着色器::tp着色器 vs, ps;
	v着色器工厂.f读取着色器(vs, C程序::f计算路径(L"~/shader/vs_image0.cso").c_str());
	v着色器工厂.f读取着色器(ps, C程序::f计算路径(L"~/shader/ps_image0.cso").c_str());
	const auto v顶点跨度 = 着色器::fc跨度(vs);
	a三维.f创建顶点着色器(m顶点着色器, v顶点跨度);
	a三维.f创建输入布局(m输入布局, v顶点跨度, v顶点格式);
	a三维.f创建像素着色器(m像素着色器, 着色器::fc跨度(ps));
	m缓存.m顶点缓冲.f初始化(sizeof(S顶点顶点), c顶点缓存数量);
	m缓存.m索引缓冲.f初始化(sizeof(WORD), c索引缓存数量);
	m缓存.mf刷新回调 = [this]() {
		f自动准备();
	};
	m常量缓冲 = a引擎.fg二维常量缓冲();
}
C画图片::~C画图片() {
}
void C画图片::f准备() {
	m渲染控制.fs顶点着色器(m顶点着色器.Get());
	m渲染控制.fs像素着色器(m像素着色器.Get());
	m渲染控制.fs输入布局(m输入布局.Get());
	m渲染控制.fs图元拓扑(三维::E图元拓扑::e列表三角形);
	m渲染控制.fs采样器(0, m渲染状态.m采样器.m纹理.Get());
	m渲染控制.fs光栅化(m渲染状态.m光栅化.m显示隐藏面.Get());
	m渲染控制.fs混合(m渲染状态.m混合.m开启透明.Get());
	m渲染控制.fs深度模板(m渲染状态.m深度模板.m总是覆盖.Get());
	m渲染控制.fs常量缓冲(0, m常量缓冲.Get());
}
void C画图片::f刷新() {
	m缓存.f刷新();
}
void C画图片::fs坐标(const t向量2 &a坐标) {
	m坐标 = a坐标;
}
void C画图片::fs透明度(float a透明度) {
	m透明度 = a透明度;
}
void C画图片::fs纹理(三维::tp纹理 a纹理) {
	if (m纹理 != a纹理) {
		f刷新();
		m纹理 = a纹理;
	}
}
void C画图片::f变换_重置() {
	m矩阵 = 数学::S矩阵4::fc单位();
}
void C画图片::f变换_旋转(const t向量3 &a旋转) {
	if (a旋转.z != 0) {
		m矩阵 *= 数学::S矩阵4::fc绕z旋转(a旋转.z);
	}
	if (a旋转.x != 0) {
		m矩阵 *= 数学::S矩阵4::fc绕x旋转(a旋转.y);
	}
	if (a旋转.y != 0) {
		m矩阵 *= 数学::S矩阵4::fc绕y旋转(a旋转.y);
	}
}
void C画图片::f变换_旋转(float a旋转) {
	m矩阵 *= 数学::S矩阵4::fc绕z旋转(a旋转);
}
void C画图片::f变换_翻转(float x, float y) {
	if (x != 0) {
		m矩阵 *= 数学::S矩阵4::fc绕x旋转(y);
	}
	if (y != 0) {
		m矩阵 *= 数学::S矩阵4::fc绕y旋转(y);
	}
}
void C画图片::f变换_缩放(float x, float y) {
	m矩阵 *= 数学::S矩阵4::fc缩放(x, y, 1);
}
void C画图片::f画图片(const S顶点矩形 &a矩形) {
	f自动准备();
	//顶点
	S顶点顶点 v顶点[4];
	auto f赋顶点 = [&](S顶点顶点 &a顶点, int x, int y) {
		//坐标
		数学::S向量4 v{0, 0, 0, 1};
		v.x += a矩形.m坐标[x];
		v.y += a矩形.m坐标[y];
		v = v * m矩阵;
		a顶点.m坐标.x = v.x + m坐标.x;
		a顶点.m坐标.y = v.y + m坐标.y;
		//纹理
		a顶点.m纹理.x = a矩形.m纹理[x];
		a顶点.m纹理.y = a矩形.m纹理[y];
		//透明度
		a顶点.m透明度 = m透明度;
	};
	f赋顶点(v顶点[0], 0, 1);	//左上
	f赋顶点(v顶点[1], 2, 1);	//右上
	f赋顶点(v顶点[2], 0, 3);	//左下
	f赋顶点(v顶点[3], 2, 3);	//右下
	//索引
	WORD v索引[] = {
		0, 1, 2,
		1, 3, 2
	};
	//复制
	m渲染控制.fs纹理(0, m纹理.Get());
	m缓存.f复制(v顶点, sizeof(v顶点), v索引, sizeof(v索引));
}
}
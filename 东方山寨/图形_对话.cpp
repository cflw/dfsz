#include "图形_对话.h"
#include "图形工厂.h"
#include "游戏.h"
#include "图形引擎.h"
namespace 东方山寨 {
//==============================================================================
// 对话框
//==============================================================================
C对话框::C对话框(const S对话参数_对话 &a) {
	auto &v二维 = C游戏::fg图形().fg二维();
	m画图形 = v二维.fc画图形(v二维.fc纯色画笔(t颜色::c黑));
	m画文本 = v二维.fc画文本();
	m文本效果 = v二维.fc文本效果();
	auto &v文本工厂 = v二维.fg文本工厂();
	二维::S文本格式参数 v文本格式参数;
	v文本格式参数.fs垂直对齐(二维::E文本垂直对齐::e中);
	v文本格式参数.fs水平对齐(二维::E文本水平对齐::e中);
	m文本布局 = v文本工厂.fc文本布局(a.m文本, v文本格式参数);
	//计算文本度量
	DWRITE_TEXT_METRICS v文本度量;
	m文本布局->GetMetrics(&v文本度量);
	m边框实际宽 = v文本度量.width + c边框 * 2;
	m边框实际高 = v文本度量.height + c边框 * 2;
	//其它
	m方向 = a.m方向;
}
void C对话框::f接口_计算() {
	if (m标志[E标志::e结束]) {
		m透明度 -= c透明度速度;
	} else {
		m透明度 = 数学::f线性渐变<float>(m透明度, 1, c透明度速度);
	}
}
void C对话框::f接口_更新() {
	m画图形->fs透明度(m透明度 * c对话框透明度);
	m画文本->fs透明度(m透明度);
	m边框显示宽 = 数学::f插值<float>(0, m边框实际宽, m透明度);
}
void C对话框::f接口_显示() const {
	//画图形
	const float v左 = m方向 ? (c开始位置x - m边框显示宽) : (-c开始位置x);
	const float v右 = m方向 ? (c开始位置x) : (-c开始位置x + m边框显示宽);
	const float v下 = c开始位置y - m边框实际高;
	const 数学::S向量2 v中心 = {数学::f算术平均(v左, v右), 数学::f算术平均(c开始位置y, v下)};
	const 数学::S向量2 v半尺寸 = {数学::f差<float>(v左, v右) / 2, 数学::f差<float>(c开始位置y, v下) / 2};
	m画图形->f填充圆角矩形(数学::S圆角矩形(v中心, v半尺寸, {c边框, c边框}));
	//画文本
	m画文本->fs区域(v中心);
	m画文本->f绘制文本布局(m文本布局.Get(), m文本效果.Get());
}
bool C对话框::f接口_i可销毁() const {
	if (m标志[E标志::e结束]) {
		return m透明度 <= 0;
	}
	return false;
}
//==============================================================================
// 对话立绘接口
//==============================================================================
void I对话立绘::f接口_计算() {
	const float v过秒 = C游戏::fg内容().fg游戏速度().fg秒();
	const float v速度 = v过秒 * c动画速度;
	const float v出现目标 = m标志[I图形::E标志::e结束] ? 0 : 1;
	m出现 = 数学::f线性渐变<float>(m出现, v出现目标, v速度);
	const float v焦点目标 = m标志[I对话立绘::E标记::e焦点] ? 1 : 0;
	m焦点 = 数学::f线性渐变<float>(m焦点, v焦点目标, v速度);
}
void I对话立绘::f接口_显示() const {
	const float v灰 = 数学::f插值<float>(0.5f, 1, m焦点);
	const float v透明 = std::min<float>(m出现, 数学::f插值<float>(0.8f, 1, m焦点));
	static auto &v画图形 = C游戏::fg图形().fg画图形();
	v画图形.fs颜色(数学::S颜色::fc黑白(v灰, v透明));
	v画图形.f填充矩形(数学::S矩形(m坐标, {64, 64}));
}
bool I对话立绘::f接口_i可销毁() const {
	return m标志[I图形::E标志::e结束] && m出现 <= 0;
}
void I对话立绘::f接口_初始化(const S图形参数 &p) {
	m方向 = p.m标志[E初始化标记::e方向];
	m坐标.x = m方向 ? c开始位置x : -c开始位置x;
	m坐标.y = c开始位置y;
}
void I对话立绘::f接口_改变表情(E立绘表情) {
}
void I对话立绘::f动作_表情(E立绘表情 p) {
	this->f接口_改变表情(p);
}
void I对话立绘::f动作_聚焦() {
	m标志[I对话立绘::E标记::e焦点] = true;
}
void I对话立绘::f动作_失焦() {
	m标志[I对话立绘::E标记::e焦点] = false;
}
}	//namespace 东方山寨